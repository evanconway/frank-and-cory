20th of April, 2024

Time to add a planning file since I'm running into stuff I want to to think through.

Right now I'm struggling again with clickables and ensuring they don't overlap with one-another. I was having trouble figuring out how to sort through them to get the right draw and logic order. But I realized this can't be done in the same loop. An object that visually is on top of other objects must have its logic processed first, but must be drawn last. So we need a different loop for logic and drawing.

I just realized that we'll need to split up the update and draw logic of clickables. That is of course because we'll need to be able to draw them without updating them. For example, during dialog scenes.

I just added some basic dialog stuff. We should consider what functions we want in order to add more dialog. Right now I just have a simple function which takes an array of text which starts the logic. But this will have 2 different characters frequently speaking with eachother. We'll need different text bubbles, sounds, and text positions for the different characters, as well as the different scenes. It needs to be easy to declare what kind of speech the line should have when delivered. Furthermore, I think there are situations where we'll want to deliver dialog, perform some sort of small animation or event, then go back to dialog. So we need to be able to easily link dialog updateables to other updateables. For example Jude requested that the opening contain dialog between Frank and Cory which has a small light activation sequence in between lines of dialog. 

Well, right now our dialog logic creates an array of updateables that all link to eachother. What if we added a function which linked the end of a dialog sequence to another updateable? Our dialog function looks like this:

updateable_start_dialog(dialog_steps_data)

Perhaps we could add a "after_dialog_updateable" field?

updateable_start_dialog(dialog_steps_data, after_dialog_updateable=undefined)

Our dialog logic already strings each dialog updateable to the next updateable in the dialog array. So simply supplying this value to the function means we could easily string the last dialog updateable to the given value, or simply keep it undefined. As for stringing updateables to dialog, we could simply invoke the updateable_start_dialog function in the updateable.

21st of April, 2024

Something I've just realized is we have no way of executing a specific function on each dialog step with our current system. But I don't think this should be too tricky to add. The on_step() function could just be part of the step struct passed into each entry of the dialog array. The nice thing about doing it like this is we don't have to keep track of which step is doing what when deciding on_step logic.

There should be a better way to declare updateables. Right now I end up with this long callback-hell looking string of events. But it should be possible to line stuff up in an array. And have some sort of other function link them all together. But maybe we won't worry about that yet. It may only be a few spots where we have large sequences of events anyway. Ah... but I just went back to adjust one of my sequences and I got frustrated immediately. Let's work on introducting a updateable_set_linked_array function or something which does what we described above.

To link updateables together they must specifically reference one-another. And they must somehow know when they are finished. Perhaps we could just insist that updateables given to this array function have a is_finished() defined. 

Actually let's not worry about this. I changed the updateable_start_dialog function to simply return the first updateable in the chain of dialogs. And I manually set the next updateable, we just do it in reverse order. It's still fairly clearly, gives me flexibility, and doesn't require extra work. We'll do that until there seems to be more of a need.

Making progress with logic that's easy to add more steps to. I realized a way to make time based animations that don't require specifying exact step indexes. It looks like this:

{
    time: 0,
    step: 0,
    steps: [
        function() {
            // do stuff
            if (time > arbitrary_value) {
                time = 0;
                step++;
            }
        },
        function() {
            // do different stuff
            if (time > arbitrary_value) {
                time = 0;
                step++;
            }
        },
        function() {
            // do third different stuff
            if (time > arbitrary_value) {
                time = 0;
                step++;
            }
        },
    ],
    update: function() {
        time += 1;
        steps[step]();
    },
}

It might be possible to abstract this away further, but let's just keep using this for now.

I also realized we may want to rely more on global values for state than only controlling it per updateable. For example, I have an updateable that modifies the position of a sprite, and I want it to link directly to a dialog updateable that also modifies the position of that sprite. But our logic doesn't account for this gap well enough, so there is a single frame where the sprite reverts to its original position. Perhaps we could add an entire pre_clickables_logic() function to the dialog function, but that seems clunky? Actually no, let's do that instead. I like the idea of the default world staying consistent and updateables modifying it. 

Oh I see how I did it. There's an "on_step" option for individual dialog steps. But this system doesn't account for an on_step() that we want to execute for all dialog steps. Let's try adding an on_step_all() parameter to the function and see how we like that.

Ya, a on_step_all() function made the most sense. The bugs are fixed and are system is working better now. Although we don't have specifics from Jude, I think now we should start fleshing out different dialog delivery for the different characters. It doesn't even need to be correct, just different. That way it'll be easier to edit in correct fonts, sounds, positions, and whatever when we know exactly what we want.

Making a note that I think the dialog function needs to accept a parameter object. We've got too many things it needs and too many combinations of how they might exist.

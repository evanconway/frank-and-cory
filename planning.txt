20th of April, 2024

Time to add a planning file since I'm running into stuff I want to to think through.

Right now I'm struggling again with clickables and ensuring they don't overlap with one-another. I was having trouble figuring out how to sort through them to get the right draw and logic order. But I realized this can't be done in the same loop. An object that visually is on top of other objects must have its logic processed first, but must be drawn last. So we need a different loop for logic and drawing.

I just realized that we'll need to split up the update and draw logic of clickables. That is of course because we'll need to be able to draw them without updating them. For example, during dialog scenes.

I just added some basic dialog stuff. We should consider what functions we want in order to add more dialog. Right now I just have a simple function which takes an array of text which starts the logic. But this will have 2 different characters frequently speaking with eachother. We'll need different text bubbles, sounds, and text positions for the different characters, as well as the different scenes. It needs to be easy to declare what kind of speech the line should have when delivered. Furthermore, I think there are situations where we'll want to deliver dialog, perform some sort of small animation or event, then go back to dialog. So we need to be able to easily link dialog updateables to other updateables. For example Jude requested that the opening contain dialog between Frank and Cory which has a small light activation sequence in between lines of dialog. 

Well, right now our dialog logic creates an array of updateables that all link to eachother. What if we added a function which linked the end of a dialog sequence to another updateable? Our dialog function looks like this:

updateable_start_dialog(dialog_steps_data)

Perhaps we could add a "after_dialog_updateable" field?

updateable_start_dialog(dialog_steps_data, after_dialog_updateable=undefined)

Our dialog logic already strings each dialog updateable to the next updateable in the dialog array. So simply supplying this value to the function means we could easily string the last dialog updateable to the given value, or simply keep it undefined. As for stringing updateables to dialog, we could simply invoke the updateable_start_dialog function in the updateable.

21st of April, 2024

Something I've just realized is we have no way of executing a specific function on each dialog step with our current system. But I don't think this should be too tricky to add. The on_step() function could just be part of the step struct passed into each entry of the dialog array. The nice thing about doing it like this is we don't have to keep track of which step is doing what when deciding on_step logic.

There should be a better way to declare updateables. Right now I end up with this long callback-hell looking string of events. But it should be possible to line stuff up in an array. And have some sort of other function link them all together. But maybe we won't worry about that yet. It may only be a few spots where we have large sequences of events anyway. Ah... but I just went back to adjust one of my sequences and I got frustrated immediately. Let's work on introducting a updateable_set_linked_array function or something which does what we described above.

To link updateables together they must specifically reference one-another. And they must somehow know when they are finished. Perhaps we could just insist that updateables given to this array function have a is_finished() defined. 

Actually let's not worry about this. I changed the updateable_start_dialog function to simply return the first updateable in the chain of dialogs. And I manually set the next updateable, we just do it in reverse order. It's still fairly clearly, gives me flexibility, and doesn't require extra work. We'll do that until there seems to be more of a need.

Making progress with logic that's easy to add more steps to. I realized a way to make time based animations that don't require specifying exact step indexes. It looks like this:

{
    time: 0,
    step: 0,
    steps: [
        function() {
            // do stuff
            if (time > arbitrary_value) {
                time = 0;
                step++;
            }
        },
        function() {
            // do different stuff
            if (time > arbitrary_value) {
                time = 0;
                step++;
            }
        },
        function() {
            // do third different stuff
            if (time > arbitrary_value) {
                time = 0;
                step++;
            }
        },
    ],
    update: function() {
        time += 1;
        steps[step]();
    },
}

It might be possible to abstract this away further, but let's just keep using this for now.

I also realized we may want to rely more on global values for state than only controlling it per updateable. For example, I have an updateable that modifies the position of a sprite, and I want it to link directly to a dialog updateable that also modifies the position of that sprite. But our logic doesn't account for this gap well enough, so there is a single frame where the sprite reverts to its original position. Perhaps we could add an entire pre_clickables_logic() function to the dialog function, but that seems clunky? Actually no, let's do that instead. I like the idea of the default world staying consistent and updateables modifying it. 

Oh I see how I did it. There's an "on_step" option for individual dialog steps. But this system doesn't account for an on_step() that we want to execute for all dialog steps. Let's try adding an on_step_all() parameter to the function and see how we like that.

Ya, a on_step_all() function made the most sense. The bugs are fixed and are system is working better now. Although we don't have specifics from Jude, I think now we should start fleshing out different dialog delivery for the different characters. It doesn't even need to be correct, just different. That way it'll be easier to edit in correct fonts, sounds, positions, and whatever when we know exactly what we want.

Making a note that I think the dialog function needs to accept a parameter object. We've got too many things it needs and too many combinations of how they might exist.

We got a pretty good system going. I was looking over the code for the intro and realized how straight forward it is for linear game logic. I almost wonder if we should remove the general update function in favor of always insisting some sort of updateable be defined at any point. We could define our linear logic in scripts and name the scripts depending on what's happening in the game story.

Something that's bothering me is the typing doesn't start with character 0. Character 0 is already typed which throws off my plans for things like ellipsis. Let's see if we can dig in and make that work properly.

Fixed it. The system was not setting the time_ms for typing logic to the new time_between_types when a new typing speed was detected. Need to make sure I add this change to the TDS library.

2nd of April, 2024

Allison got us a bunch of assets, so we've been throwing those in. I changed how the desk light scene works so we're drawing a black sprite with a cutout of the lamp light. It was easier to get a shape that looked correct there. Right now I noticed that the disabled lamp asset does not block hovering over the arms behind Frank. So next let's rework the clickable object so disabled objects can still consume hover, just not act on it.


20th of May, 2024

We've been so distracted by job hunt stuff. We need to get our head back in the game for this. Last time we though about this seriously we decided the next major code challenge was the story machine. In this mini game the player will be presented with pieces of audio for a story, and the player must assemble them in the correct order. There will be 4 "chapters" to this story, and for each chapter there's going to be dialog, sound effects, and music. That's 3 pieces of audio for each chapter, so a total of 12 pieces of audio in total.

The audio pieces will be represented in game as rolls of tape on a rack. Something like this: https://www.tdiinternational.com/wp-content/uploads/2016/04/5-door-tape-reel-desiccator.jpg or maybe this: https://www.descoindustries.com/Images/Catalog/highResolution/37564.jpg

Jude has suggested having the tapes color coded based on their role (dialog, sfx, music). This may make it too easy, but we'll worry about that later. Right now we have to think through the interface to put this together. Here is my plan.

There will be a rack of audio tapes on one side (I'm imagining the left side in my head). Then there is a machine that's almost the whole screen. There should be 12 slots, 3 rows, 4 slots each row. Click and dragging a reel from the rack to one of these slots will place it in the slot. Above each column of slots there should be a play button. Hitting the play button will play all audio in just that column. Somewhere else there will be a play and stop button that controls all tapes, but from the start of the story. Originally I was thinking we'd need a complex moveable head system, and a place to listen to tapes by themselves, but this may be all we need.

Once all tapes are assembled in the correct order, Jude wants some sort of animation to play out that synchs with the player created audio. This shouldn't be too hard to do.


I was about to explain that the most difficult issue in all this is whether or not this will happen in a separate room, or in the same room. However it does not matter. We can create an object that contains all of these elements on its own. We'll simply place that object in any room it needs to be. The "object" will actually contain a bunch of sub-objects. Each of those will be buttons the player will interact with.

Let's start with creating a room we can access with a debug key where this object will exist. That way we can test it and perfect it.


25th of May, 2024

Started thinking through the story maker. So the issue is we rigged up clickables like they are individual things that are updated independantly of one-another. For the story machine, each button will do something specific. I was planning on creating one object that manages everything, but perhaps this isn't the way since I'd have to re-code so much infrastructure. I was thinking that we should actually have a script or something that creates a bunch of clickables objects all rigged to interact with one another. And probably another script that removes them.

We'll also need to create draggable elements. This is for the tape reels. I'm imagining they should snap to locations they can get slotted into, so perhaps each draggable element will need an array of targets, or positions that are valid. Not sure how I'll store these. Perhaps they should also be objects? I think the draggable elements will have to share the hover logic with the clickable elements since we don't want elements fighting with each other. We've started the habit of storing state for different parts of the game in individual scripts so we should be able to do that here as well. We can track where each tape reel is on the story machine.

Ok, I don't think I'm too worried about play and stop buttons for the audio. But I think the draggable elements that move tape reels around will be the next major engineering challenge. So let's do that next. I'm mostly concerned about positions though... should we hand code these or make them some sort of object placeable in the room? I'm tempted to make it objects so that we can hand place the exact position each thing should be at. At least for this project, since we're only dealing with tape reels, we could make the sprite for the "draggable_position" object be a tape reel, so we can be very confident where they're supposed to go. And I suppose the draggable object itself could store references to each of these position objects. We'll have a "being_dragged" state for the draggables that determines if we should start trying to snap, and we'll iterate over each of the position references to determine if we're close to any of them. That way we should be able to keep track of the actual dragged position, but also the position to draw the object to create the "snap" effect (draw it at the location of the snap object if it's close enough).

So for now, let's just start trying to create draggable elements in the debug room. Once we've got that let's re-assess.
I was going to make draggables a whole separate class from the clickables, but there's so much logic that clickables already handle which draggables need to do, like hovering, that I think we should make this a child of clickable and work around it. So ignore my previous comment, draggables are an extension of clickable.

We've added crude snapping logic, but I realized a flaw. If we want to pick up an element that's already snapped to a position object, it'll just automatically snap to that position object as soon as you click to drag it. So let's change the snapping to always be to an object rather than a position. That way we can tell the snap logic to ignore the object it's already snapped to.

Ah, and I just realized we need to make sure that draggable elements can't be placed in positions that are already occupied by another. I'm realizing this could get complicated quick, but fortunately I think the only elements which will be draggable are the tape reels. So we can probably ignore accounting for different kinds of draggable elements. Good. As for keeping track of held positions, I think this should actually be global rather than instance to instance. Because we'll need elements to know if a position is already filled. That implies positions should be aware if they're filled. But the elements must also know which element they're attached to. I don't want both positions referencing elements and elements referencing positions. We'll make it a map in the clickables script.
